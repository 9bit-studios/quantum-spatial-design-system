<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Core Quantum Pixel System</title>
  <style>
    :root {
      /* Color: Primary Foundation */
      --color-void-black: #0A0621;
      --color-deep-space-indigo: #131A36;
      --color-dimensional-eggplant: #331F4A;
      --color-quantum-violet: #6A3093;
      
      /* Color: Secondary Accents */
      --color-subtle-aqua: #29B6F6;
      --color-subtle-cyan: #5AC8FA;
      --color-rose-energy: #BF4080;
      --color-quantum-pulse-pink: #FF2D55;
      
      /* Color: Heritage System */
      --color-heritage-green: #2C5F2D;
      --color-heritage-pixel-green: #3DFF74;
      
      /* Animation timings */
      --transition-medium: 0.3s;
    }
    
    body {
      background-color: var(--color-void-black);
      color: white;
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif;
      margin: 0;
      padding: 24px;
      line-height: 1.5;
    }
    
    .container {
      max-width: 1024px;
      margin: 0 auto;
    }
    
    h1 {
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
      font-weight: 600;
      font-size: 28px;
      margin-bottom: 8px;
      background: linear-gradient(to right, #3DFF74, #5AC8FA, #BF4080);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    h2 {
      font-size: 20px;
      margin-top: 32px;
      margin-bottom: 16px;
      color: #FFFFFF;
    }
    
    p {
      color: rgba(255, 255, 255, 0.8);
      margin-bottom: 24px;
      max-width: 640px;
    }
    
    .section {
      margin-bottom: 48px;
    }
    
    .pixel-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 24px;
      margin-bottom: 32px;
    }
    
    .pixel-item {
      background: rgba(19, 26, 54, 0.3);
      border-radius: 12px;
      padding: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      transition: transform var(--transition-medium) ease;
    }
    
    .pixel-item:hover {
      transform: translateY(-4px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }
    
    .pixel-canvas {
      width: 100%;
      aspect-ratio: 1;
      margin-bottom: 12px;
      border-radius: 8px;
    }
    
    .pixel-name {
      font-size: 16px;
      font-weight: 500;
      margin-bottom: 4px;
    }
    
    .pixel-state {
      font-size: 14px;
      color: rgba(255, 255, 255, 0.7);
    }
    
    .controls {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      margin-bottom: 24px;
    }
    
    .control-btn {
      background: rgba(90, 200, 250, 0.1);
      border: 1px solid rgba(90, 200, 250, 0.2);
      border-radius: 8px;
      color: white;
      padding: 8px 16px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all var(--transition-medium) ease;
    }
    
    .control-btn:hover {
      background: rgba(90, 200, 250, 0.2);
    }
    
    .control-btn.active {
      background: rgba(90, 200, 250, 0.3);
      box-shadow: 0 0 8px rgba(90, 200, 250, 0.3);
    }
    
    .implementation-rules {
      background: rgba(19, 26, 54, 0.3);
      border-radius: 12px;
      padding: 24px;
      margin-bottom: 32px;
    }
    
    .rule-list {
      list-style-type: none;
      padding: 0;
      margin: 0;
    }
    
    .rule-list li {
      position: relative;
      padding-left: 24px;
      margin-bottom: 12px;
      color: rgba(255, 255, 255, 0.8);
    }
    
    .rule-list li::before {
      content: "â€¢";
      color: var(--color-subtle-cyan);
      position: absolute;
      left: 0;
    }
    
    .size-ratio {
      display: flex;
      align-items: flex-end;
      gap: 24px;
      margin-bottom: 32px;
    }
    
    .size-box {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .size-1x {
      width: 16px;
      height: 16px;
      background: var(--color-heritage-pixel-green);
      border-radius: 2px;
    }
    
    .size-2x {
      width: 32px;
      height: 32px;
      background: var(--color-subtle-cyan);
      border-radius: 4px;
    }
    
    .size-3x {
      width: 48px;
      height: 48px;
      background: var(--color-rose-energy);
      border-radius: 6px;
    }
    
    .size-4x {
      width: 64px;
      height: 64px;
      background: var(--color-quantum-violet);
      border-radius: 8px;
    }
    
    .size-label {
      margin-top: 8px;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.7);
    }
    
    @media (max-width: 768px) {
      .controls {
        flex-direction: column;
      }
      
      .pixel-grid {
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="section">
      <h1>Core Quantum Pixel System</h1>
      <p>A collection of 16 fundamental pixel variations across four quantum states. These core components form the foundation of the quantum-spatial design system.</p>
      
      <div class="controls">
        <button class="control-btn active" data-view="all">All Pixels</button>
        <button class="control-btn" data-view="materialized">Materialized</button>
        <button class="control-btn" data-view="partial">Partially Materialized</button>
        <button class="control-btn" data-view="energy">Energy State</button>
        <button class="control-btn" data-view="superposition">Superposition</button>
      </div>
      
      <div class="pixel-grid" id="pixel-grid">
        <!-- Pixels will be generated here by JavaScript -->
      </div>
    </div>
    
    <div class="section">
      <h2>Pixel States</h2>
      <p>The quantum pixel system consists of four fundamental states, each representing a distinct phase in the quantum materialization process.</p>
      
      <div class="implementation-rules">
        <h3>State Descriptions</h3>
        <ul class="rule-list">
          <li><strong>Fully Materialized (Solid):</strong> These pixels have a defined physical presence with clear boundaries and solid forms. They reflect the heritage of traditional pixel art while incorporating dimensional properties.</li>
          <li><strong>Partially Materialized (Translucent):</strong> Pixels in transition between energy and solid states. They feature semi-transparent areas and subtle particle effects, embodying the concept of quantum indeterminacy.</li>
          <li><strong>Energy State (Glowing):</strong> Pure quantum energy forms with bright, glowing outlines. These pixels exist as wave patterns rather than solid matter, pulsating with dimensional energy.</li>
          <li><strong>Superposition State (Layered):</strong> The most complex quantum state where pixels exist in multiple positions simultaneously. These components feature overlapping forms and phase shifts between states.</li>
        </ul>
      </div>
    </div>
    
    <div class="section">
      <h2>Size Ratio System</h2>
      <p>All quantum pixels maintain a consistent size relationship to ensure proper scaling across interfaces. The base size (1x) is 16px, with scaled variants at 2x (32px), 3x (48px), and 4x (64px).</p>
      
      <div class="size-ratio">
        <div class="size-box">
          <div class="size-1x"></div>
          <span class="size-label">1x (16px)</span>
        </div>
        <div class="size-box">
          <div class="size-2x"></div>
          <span class="size-label">2x (32px)</span>
        </div>
        <div class="size-box">
          <div class="size-3x"></div>
          <span class="size-label">3x (48px)</span>
        </div>
        <div class="size-box">
          <div class="size-4x"></div>
          <span class="size-label">4x (64px)</span>
        </div>
      </div>
    </div>
    
    <div class="section">
      <h2>Implementation Rules</h2>
      <div class="implementation-rules">
        <ul class="rule-list">
          <li><strong>State Combination:</strong> Always include at least 3 different pixel states in any composition for visual richness and quantum-spatial authenticity.</li>
          <li><strong>Spacing Requirements:</strong> Maintain minimum spacing between pixels of at least 50% of the pixel size to preserve quantum field integrity.</li>
          <li><strong>Distinctive Patterns:</strong> Ensure quantum pixels never create recognizable patterns from classic games to maintain a unique visual language.</li>
          <li><strong>Animation Transitions:</strong> When animating between states, use fade, particle, or dimensional shift effects to maintain quantum coherence.</li>
        </ul>
      </div>
    </div>
  </div>

  <script>
    // Core pixel definitions
    const pixelDefinitions = [
      // Materialized (Solid) State - 4 variations
      {
        name: "Quantum Cube",
        state: "materialized",
        description: "Solid cubic form with dimensional edges",
        primaryColor: "#2C5F2D",
        accentColor: "#3DFF74",
        secondaryColor: "#1B3D1A"
      },
      {
        name: "Spatial Octahedron",
        state: "materialized",
        description: "Solid octahedral form with angular planes",
        primaryColor: "#331F4A",
        accentColor: "#5AC8FA",
        secondaryColor: "#1E1F5C"
      },
      {
        name: "Void Sphere",
        state: "materialized",
        description: "Solid spherical form with depth mapping",
        primaryColor: "#6A3093", 
        accentColor: "#BF4080",
        secondaryColor: "#FF2D55"
      },
      {
        name: "Heritage Block",
        state: "materialized",
        description: "Traditional pixel block with subtle dimension",
        primaryColor: "#2C5F2D",
        accentColor: "#3DFF74",
        secondaryColor: "#1B3D1A"
      },
      
      // Partially Materialized (Translucent) State - 4 variations
      {
        name: "Phase Shift",
        state: "partial",
        description: "Partially formed cube with translucent faces",
        primaryColor: "#331F4A", 
        accentColor: "#5AC8FA",
        secondaryColor: "#1E1F5C"
      },
      {
        name: "Quantum Ripple",
        state: "partial",
        description: "Wave-particle form with semi-materialized core",
        primaryColor: "#6A3093",
        accentColor: "#BF4080",
        secondaryColor: "#FF2D55"
      },
      {
        name: "Dimensional Echo",
        state: "partial",
        description: "Overlapping translucent planes",
        primaryColor: "#126D71",
        accentColor: "#29B6F6",
        secondaryColor: "#131A36"
      },
      {
        name: "Transient Form",
        state: "partial",
        description: "Morphing state between energy and solid",
        primaryColor: "#331F4A",
        accentColor: "#5AC8FA",
        secondaryColor: "#1E1F5C"
      },
      
      // Energy State (Glowing Outlines) - 4 variations
      {
        name: "Energy Grid",
        state: "energy",
        description: "Pulsating energy network with node points",
        primaryColor: "#FF2D55",
        accentColor: "#BF4080",
        secondaryColor: "#6A3093"
      },
      {
        name: "Quantum Core",
        state: "energy",
        description: "Pure energy core with radiating waves",
        primaryColor: "#5AC8FA",
        accentColor: "#29B6F6",
        secondaryColor: "#126D71"
      },
      {
        name: "Void Stream",
        state: "energy",
        description: "Flowing energy currents in deep space",
        primaryColor: "#6A3093",
        accentColor: "#BF4080",
        secondaryColor: "#FF2D55"
      },
      {
        name: "Ethereal Circuit",
        state: "energy",
        description: "Interconnected energy paths",
        primaryColor: "#3DFF74",
        accentColor: "#29B6F6",
        secondaryColor: "#2C5F2D"
      },
      
      // Superposition State (Multiple Layered Positions) - 4 variations
      {
        name: "Quantum Plural",
        state: "superposition",
        description: "Multiple states simultaneously occupying same space",
        primaryColor: "#FFFFFF",
        accentColor: "#5AC8FA",
        secondaryColor: "#FF2D55"
      },
      {
        name: "Echo Chamber",
        state: "superposition",
        description: "Recursive forms phasing between states",
        primaryColor: "#FFFFFF",
        accentColor: "#BF4080",
        secondaryColor: "#6A3093"
      },
      {
        name: "Dimensional Fold",
        state: "superposition",
        description: "Overlapping realities with phase shift",
        primaryColor: "#FFFFFF",
        accentColor: "#3DFF74",
        secondaryColor: "#2C5F2D"
      },
      {
        name: "Reality Cascade",
        state: "superposition",
        description: "Multiple probability waves collapsing",
        primaryColor: "#FFFFFF",
        accentColor: "#29B6F6",
        secondaryColor: "#126D71"
      }
    ];
    
    // Rendering functions
    function renderPixel(canvas, pixelDef, is3D = true) {
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      
      // Clear canvas
      ctx.clearRect(0, 0, width, height);
      
      // Choose rendering method based on pixel state
      switch(pixelDef.state) {
        case 'materialized':
          renderMaterializedPixel(ctx, width, height, pixelDef, is3D);
          break;
        case 'partial':
          renderPartialPixel(ctx, width, height, pixelDef, is3D);
          break;
        case 'energy':
          renderEnergyPixel(ctx, width, height, pixelDef, is3D);
          break;
        case 'superposition':
          renderSuperpositionPixel(ctx, width, height, pixelDef, is3D);
          break;
      }
    }
    
    // Render a fully materialized pixel
    function renderMaterializedPixel(ctx, width, height, pixelDef, is3D) {
      const { primaryColor, accentColor, secondaryColor } = pixelDef;
      const centerX = width / 2;
      const centerY = height / 2;
      const size = Math.min(width, height) * 0.4;
      
      if (is3D) {
        // 3D isometric cube
        ctx.save();
        ctx.translate(centerX, centerY);
        
        // Apply shadow for depth
        ctx.shadowColor = accentColor;
        ctx.shadowBlur = 10;
        
        // Top face
        ctx.fillStyle = primaryColor;
        ctx.beginPath();
        ctx.moveTo(0, -size / 2);
        ctx.lineTo(size / 2, -size / 4);
        ctx.lineTo(0, 0);
        ctx.lineTo(-size / 2, -size / 4);
        ctx.closePath();
        ctx.fill();
        
        // Left face
        ctx.fillStyle = secondaryColor;
        ctx.beginPath();
        ctx.moveTo(-size / 2, -size / 4);
        ctx.lineTo(0, 0);
        ctx.lineTo(0, size / 2);
        ctx.lineTo(-size / 2, size / 4);
        ctx.closePath();
        ctx.fill();
        
        // Right face
        ctx.fillStyle = primaryColor;
        ctx.beginPath();
        ctx.moveTo(size / 2, -size / 4);
        ctx.lineTo(0, 0);
        ctx.lineTo(0, size / 2);
        ctx.lineTo(size / 2, size / 4);
        ctx.closePath();
        ctx.fill();
        
        // Edge highlights
        ctx.strokeStyle = accentColor;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, -size / 2);
        ctx.lineTo(size / 2, -size / 4);
        ctx.lineTo(size / 2, size / 4);
        ctx.lineTo(0, size / 2);
        ctx.lineTo(-size / 2, size / 4);
        ctx.lineTo(-size / 2, -size / 4);
        ctx.closePath();
        ctx.stroke();
        
        ctx.restore();
      } else {
        // 2D pixel
        const pixelSize = size * 0.8;
        ctx.fillStyle = primaryColor;
        ctx.strokeStyle = accentColor;
        ctx.lineWidth = 2;
        
        // Create rounded rectangle
        ctx.beginPath();
        ctx.roundRect(centerX - pixelSize/2, centerY - pixelSize/2, pixelSize, pixelSize, 4);
        ctx.fill();
        ctx.stroke();
        
        // Inner highlight
        ctx.strokeStyle = accentColor;
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.roundRect(centerX - pixelSize/2 + 5, centerY - pixelSize/2 + 5, pixelSize - 10, pixelSize - 10, 2);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
    }
    
    // Render a partially materialized pixel
    function renderPartialPixel(ctx, width, height, pixelDef, is3D) {
      const { primaryColor, accentColor, secondaryColor } = pixelDef;
      const centerX = width / 2;
      const centerY = height / 2;
      const size = Math.min(width, height) * 0.4;
      
      // Create gradient
      const gradient = ctx.createRadialGradient(
        centerX, centerY, 0,
        centerX, centerY, size
      );
      gradient.addColorStop(0, accentColor + "80"); // 50% opacity
      gradient.addColorStop(0.6, primaryColor + "60"); // 40% opacity
      gradient.addColorStop(1, primaryColor + "00"); // 0% opacity
      
      if (is3D) {
        ctx.save();
        ctx.translate(centerX, centerY);
        
        // Background glow
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(0, 0, size, 0, Math.PI * 2);
        ctx.fill();
        
        // Semi-transparent cube structure
        ctx.globalAlpha = 0.7;
        
        // Top face (partial)
        ctx.fillStyle = primaryColor;
        ctx.beginPath();
        ctx.moveTo(0, -size / 2);
        ctx.lineTo(size / 2, -size / 4);
        ctx.lineTo(0, 0);
        ctx.lineTo(-size / 2, -size / 4);
        ctx.closePath();
        ctx.fill();
        
        // Partial edges
        ctx.strokeStyle = accentColor;
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 3]);
        ctx.beginPath();
        ctx.moveTo(0, -size / 2);
        ctx.lineTo(size / 2, -size / 4);
        ctx.lineTo(size / 2, size / 4);
        ctx.lineTo(0, size / 2);
        ctx.lineTo(-size / 2, size / 4);
        ctx.lineTo(-size / 2, -size / 4);
        ctx.closePath();
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Energy particles
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = accentColor;
        
        // Draw 5 random particles
        for (let i = 0; i < 5; i++) {
          const angle = Math.random() * Math.PI * 2;
          const distance = Math.random() * size * 0.8;
          const particleSize = Math.random() * 4 + 2;
          
          ctx.beginPath();
          ctx.arc(
            Math.cos(angle) * distance,
            Math.sin(angle) * distance,
            particleSize,
            0,
            Math.PI * 2
          );
          ctx.fill();
        }
        
        ctx.restore();
      } else {
        // 2D partially materialized pixel
        const pixelSize = size * 0.8;
        
        // Background glow
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(centerX, centerY, size, 0, Math.PI * 2);
        ctx.fill();
        
        // Semi-transparent square
        ctx.globalAlpha = 0.6;
        ctx.fillStyle = primaryColor;
        ctx.strokeStyle = accentColor;
        ctx.lineWidth = 2;
        ctx.setLineDash([4, 2]);
        
        ctx.beginPath();
        ctx.roundRect(centerX - pixelSize/2, centerY - pixelSize/2, pixelSize, pixelSize, 4);
        ctx.fill();
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Energy particles
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = accentColor;
        
        // Draw 5 random particles
        for (let i = 0; i < 5; i++) {
          const angle = Math.random() * Math.PI * 2;
          const distance = Math.random() * pixelSize * 0.6;
          const particleSize = Math.random() * 3 + 1.5;
          
          ctx.beginPath();
          ctx.arc(
            centerX + Math.cos(angle) * distance,
            centerY + Math.sin(angle) * distance,
            particleSize,
            0,
            Math.PI * 2
          );
          ctx.fill();
        }
        
        ctx.globalAlpha = 1;
      }
    }
    
    // Render an energy state pixel
    function renderEnergyPixel(ctx, width, height, pixelDef, is3D) {
      const { primaryColor, accentColor, secondaryColor } = pixelDef;
      const centerX = width / 2;
      const centerY = height / 2;
      const size = Math.min(width, height) * 0.4;
      
      // Create energy gradient
      const gradient = ctx.createRadialGradient(
        centerX, centerY, 0,
        centerX, centerY, size
      );
      gradient.addColorStop(0, accentColor);
      gradient.addColorStop(0.5, primaryColor + "80"); // 50% opacity
      gradient.addColorStop(1, primaryColor + "00"); // 0% opacity
      
      if (is3D) {
        ctx.save();
        ctx.translate(centerX, centerY);
        
        // Energy field
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(0, 0, size * 0.8, 0, Math.PI * 2);
        ctx.fill();
        
        // Energy core
        ctx.fillStyle = accentColor;
        ctx.beginPath();
        ctx.arc(0, 0, size * 0.15, 0, Math.PI * 2);
        ctx.fill();
        
        // Energy orbits
        ctx.strokeStyle = accentColor;
        ctx.lineWidth = 2;
        
        // Orbit 1
        ctx.beginPath();
        ctx.ellipse(0, 0, size * 0.6, size * 0.3, Math.PI / 4, 0, Math.PI * 2);
        ctx.stroke();
        
        // Orbit 2
        ctx.beginPath();
        ctx.ellipse(0, 0, size * 0.5, size * 0.25, -Math.PI / 6, 0, Math.PI * 2);
        ctx.stroke();
        
        // Energy particles on orbits
        ctx.fillStyle = secondaryColor;
        
        // 3 particles on first orbit
        for (let i = 0; i < 3; i++) {
          const angle = (i / 3) * Math.PI * 2;
          ctx.beginPath();
          ctx.arc(
            Math.cos(angle + Math.PI/4) * size * 0.6,
            Math.sin(angle + Math.PI/4) * size * 0.3,
            4,
            0,
            Math.PI * 2
          );
          ctx.fill();
        }
        
        // 2 particles on second orbit
        for (let i = 0; i < 2; i++) {
          const angle = (i / 2) * Math.PI * 2;
          ctx.beginPath();
          ctx.arc(
            Math.cos(angle - Math.PI/6) * size * 0.5,
            Math.sin(angle - Math.PI/6) * size * 0.25,
            3,
            0,
            Math.PI * 2
          );
          ctx.fill();
        }
        
        ctx.restore();
      } else {
        // 2D energy pixel
        const pixelSize = size * 0.8;
        
        // Energy field
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(centerX, centerY, size * 0.8, 0, Math.PI * 2);
        ctx.fill();
        
        // Energy core
        ctx.fillStyle = accentColor;
        ctx.beginPath();
        ctx.arc(centerX, centerY, size * 0.15, 0, Math.PI * 2);
        ctx.fill();
        
        // Energy boundary (ghost of pixel shape)
        ctx.strokeStyle = accentColor;
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 3]);
        
        ctx.beginPath();
        ctx.roundRect(centerX - pixelSize/2, centerY - pixelSize/2, pixelSize, pixelSize, 4);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Energy particles
        ctx.fillStyle = secondaryColor;
        
        // Draw 6 random particles
        for (let i = 0; i < 6; i++) {
          const angle = Math.random() * Math.PI * 2;
          const distance = Math.random() * pixelSize * 0.7;
          const particleSize = Math.random() * 3 + 2;
          
          ctx.beginPath();
          ctx.arc(
            centerX + Math.cos(angle) * distance,
            centerY + Math.sin(angle) * distance,
            particleSize,
            0,
            Math.PI * 2
          );
          ctx.fill();
        }
      }
    }
    
    // Render a superposition state pixel
    function renderSuperpositionPixel(ctx, width, height, pixelDef, is3D) {
      const { primaryColor, accentColor, secondaryColor } = pixelDef;
      const centerX = width / 2;
      const centerY = height / 2;
      const size = Math.min(width, height) * 0.4;
      
      if (is3D) {
        ctx.save();
        ctx.translate(centerX, centerY);
        
        // Background field
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
        gradient.addColorStop(0, primaryColor + "80"); // 50% opacity
        gradient.addColorStop(0.7, secondaryColor + "40"); // 25% opacity
        gradient.addColorStop(1, "rgba(0,0,0,0)");
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(0, 0, size, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw multiple overlapping forms in different positions
        
        // Form 1 (heritage-like) - shifted left
        ctx.save();
        ctx.translate(-size * 0.2, -size * 0.1);
        ctx.globalAlpha = 0.5;
        ctx.fillStyle = "#2C5F2D"; // Heritage green
        ctx.strokeStyle = "#3DFF74"; // Heritage pixel green
        ctx.lineWidth = 1.5;
        
        ctx.beginPath();
        ctx.moveTo(0, -size * 0.3);
        ctx.lineTo(size * 0.3, -size * 0.15);
        ctx.lineTo(0, 0);
        ctx.lineTo(-size * 0.3, -size * 0.15);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        ctx.restore();
        
        // Form 2 (transitional) - centered
        ctx.globalAlpha = 0.6;
        ctx.fillStyle = "#331F4A"; // Dimensional eggplant
        ctx.strokeStyle = "#5AC8FA"; // Subtle cyan
        ctx.lineWidth = 1.5;
        
        ctx.beginPath();
        ctx.arc(0, 0, size * 0.35, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        // Form 3 (quantum) - shifted right
        ctx.save();
        ctx.translate(size * 0.15, size * 0.15);
        ctx.globalAlpha = 0.5;
        ctx.fillStyle = "#6A3093"; // Quantum violet
        ctx.strokeStyle = "#FF2D55"; // Quantum pulse pink
        ctx.lineWidth = 1.5;
        
        // Quantum shape
        ctx.beginPath();
        ctx.moveTo(-size * 0.2, -size * 0.2);
        ctx.bezierCurveTo(
          -size * 0.1, -size * 0.25,
          size * 0.1, -size * 0.25,
          size * 0.2, -size * 0.2
        );
        ctx.bezierCurveTo(
          size * 0.25, -size * 0.1,
          size * 0.25, size * 0.1,
          size * 0.2, size * 0.2
        );
        ctx.bezierCurveTo(
          size * 0.1, size * 0.25,
          -size * 0.1, size * 0.25,
          -size * 0.2, size * 0.2
        );
        ctx.bezierCurveTo(
          -size * 0.25, size * 0.1,
          -size * 0.25, -size * 0.1,
          -size * 0.2, -size * 0.2
        );
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        ctx.restore();
        
        // Core
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = primaryColor;
        ctx.beginPath();
        ctx.arc(0, 0, size * 0.12, 0, Math.PI * 2);
        ctx.fill();
        
        // Energy connectors
        ctx.globalAlpha = 0.5;
        ctx.strokeStyle = accentColor;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-size * 0.2, -size * 0.1); // Heritage position
        ctx.lineTo(0, 0); // Center
        ctx.lineTo(size * 0.15, size * 0.15); // Quantum position
        ctx.stroke();
        
        ctx.restore();
      } else {
        // 2D superposition pixel
        const pixelSize = size * 0.8;
        
        // Background field
        const gradient = ctx.createRadialGradient(
          centerX, centerY, 0,
          centerX, centerY, size
        );
        gradient.addColorStop(0, primaryColor + "80"); // 50% opacity
        gradient.addColorStop(0.7, secondaryColor + "40"); // 25% opacity
        gradient.addColorStop(1, "rgba(0,0,0,0)");
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(centerX, centerY, size, 0, Math.PI * 2);
        ctx.fill();
        
        // Form 1 - heritage-like square shifted left
        ctx.globalAlpha = 0.5;
        ctx.fillStyle = "#2C5F2D"; // Heritage green
        ctx.strokeStyle = "#3DFF74"; // Heritage pixel green
        ctx.lineWidth = 1.5;
        
        ctx.beginPath();
        ctx.roundRect(
          centerX - pixelSize/2 - 10,
          centerY - pixelSize/2 - 5,
          pixelSize * 0.7,
          pixelSize * 0.7,
          4
        );
        ctx.fill();
        ctx.stroke();
        
        // Form 2 - transitional circle centered
        ctx.globalAlpha = 0.6;
        ctx.fillStyle = "#331F4A"; // Dimensional eggplant
        ctx.strokeStyle = "#5AC8FA"; // Subtle cyan
        ctx.lineWidth = 1.5;
        
        ctx.beginPath();
        ctx.arc(centerX, centerY, pixelSize * 0.35, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        // Form 3 - quantum irregular shape shifted right
        ctx.globalAlpha = 0.5;
        ctx.fillStyle = "#6A3093"; // Quantum violet
        ctx.strokeStyle = "#FF2D55"; // Quantum pulse pink
        ctx.lineWidth = 1.5;
        
        ctx.beginPath();
        ctx.ellipse(
          centerX + 10,
          centerY + 10,
          pixelSize * 0.3,
          pixelSize * 0.4,
          Math.PI / 4,
          0,
          Math.PI * 2
        );
        ctx.fill();
        ctx.stroke();
        
        // Core
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = primaryColor;
        ctx.beginPath();
        ctx.arc(centerX, centerY, pixelSize * 0.1, 0, Math.PI * 2);
        ctx.fill();
        
        // Reset alpha
        ctx.globalAlpha = 1;
      }
    }
    
    // Generate pixel grid
    function generatePixelGrid() {
      const pixelGrid = document.getElementById('pixel-grid');
      pixelGrid.innerHTML = '';
      
      // Get active view filter
      const activeView = document.querySelector('.control-btn.active').getAttribute('data-view');
      
      // Filter pixels by active view
      const filteredPixels = activeView === 'all' ? 
        pixelDefinitions : 
        pixelDefinitions.filter(pixel => pixel.state === activeView);
      
      // Create pixel items
      filteredPixels.forEach(pixelDef => {
        // Create container
        const pixelItem = document.createElement('div');
        pixelItem.className = 'pixel-item';
        
        // Create canvas
        const canvas = document.createElement('canvas');
        canvas.className = 'pixel-canvas';
        canvas.width = 200;
        canvas.height = 200;
        
        // Create name and state labels
        const pixelName = document.createElement('div');
        pixelName.className = 'pixel-name';
        pixelName.textContent = pixelDef.name;
        
        const pixelState = document.createElement('div');
        pixelState.className = 'pixel-state';
        pixelState.textContent = `${pixelDef.state.charAt(0).toUpperCase() + pixelDef.state.slice(1)} State`;
        
        // Add elements to container
        pixelItem.appendChild(canvas);
        pixelItem.appendChild(pixelName);
        pixelItem.appendChild(pixelState);
        
        // Add to grid
        pixelGrid.appendChild(pixelItem);
        
        // Render pixel
        renderPixel(canvas, pixelDef);
      });
    }
    
    // Set up view filters
    document.querySelectorAll('.control-btn[data-view]').forEach(button => {
      button.addEventListener('click', () => {
        // Update active button
        document.querySelectorAll('.control-btn[data-view]').forEach(btn => {
          btn.classList.remove('active');
        });
        button.classList.add('active');
        
        // Update grid
        generatePixelGrid();
      });
    });
    
    // Initialize on load
    document.addEventListener('DOMContentLoaded', generatePixelGrid);
  </script>
</body>
</html>